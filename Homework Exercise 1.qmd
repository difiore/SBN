---
title: "Homework Exercise 1"
subtitle: "Network Calculations and Visualizations"
format:
  html:
    embed-resources: true
    code-overflow: wrap
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    code-summary: "Code hint"
editor_options: 
  chunk_output_type: console
---

# Introduction

You are going to practice your skills as loading social network data, extracting several network-level metrics to describe the network's structure, and calculating several node-level metrics of "importance" or "centrality".

The dataset we will work with comes from this GitHub site: [Harry Potter Character Network](https://github.com/efekarakus/potter-network).

Go to that site, move into the "data" folder, and download the two .csv files "characters.csv" and "relations.csv".

## Create a Quarto or RMarkdown Document

Create a new Quarto or RMarkdown document with code and descriptive text in which you do the following...

## Load and Clean Up the Dataset

Read the files you downloaded into R using the {tidyverse} package as two data frames, "v" (for vertices) and "e" for edges.

> **NOTE:** In the code snippet below, I have hard-coded the path to the two data files... in the Quarto/RMarkdown document you will eventually turn in to me, you should do the same, which means you will need to insert the path to the location on your computer where these files are located. If they are located in the same directory in which you started R, then the code below should work fine, but if they are in a different directory, e.g., your Documents or My Documents or Downloads folder, you will need to preface the file name with the path to the directory.

> For selecting a file to load interactively you could replace "characters.csv" or "relations.csv" with `file.choose()`, which would then open up a standard dialog box. HOWEVER, that will not work when you go to render the document to make a pretty PDF report, that approach does not work because rendering will stop if your code requires feedback from the user.

```{r}
#| message: false
library(tidyverse)
v <- read_csv("characters.csv", col_names = TRUE)
e <- read_csv("relations.csv", col_names = TRUE)
```

We now need to do some manipulations to wrangle the data get it into the format we are used to in order to make a graph object and be able to visualize it.

We first create a data frame of edges...

```{r}
#| message: false
# merge info from e and v
edges <- left_join(e, v, by = c("source" = "id"))
# drop the "source" and "bio" columns
edges <- select(edges, -c(source, bio))
# rename "name" as "from"
edges <- rename(edges, from = name)
# merge info from edges and v
edges <- left_join(edges, v, by = c("target" = "id"))
# drop the "target" and "bio" columns
edges <- select(edges, -c(target, bio))
# rename "name" as "to"
edges <- rename(edges, to = name)
# rename the "type" column
edges <- rename(edges, relationship = type)
# reorder the columns
edges <- select(edges, c("from", "to", "relationship"))
# add a new "type" column specifying that edges are undirected
edges <- mutate(edges, type = "undirected")
```

We then create a data frame of vertices...

```{r}
vertices <- data.frame(
  id = unique(c(v$name)),
  label = unique(c(v$name))
)
```

We can now create a graph object in {igraph}...

```{r}
#| message: false
library(igraph)
graph <- graph_from_data_frame(
  d = filter(edges, relationship == "+"),
  vertices = vertices,
  directed = FALSE)
graph
```

We can run the `simplify()` function from {igraph} to remove loops (edges from a vertex to itself) and multiple edges (where the same edge is specified more than once) from the graph. This particular Harry Potter dataset is noisy and has some of each of those types of edges!

```{r}
graph <- simplify(graph, remove.loops = TRUE, remove.multiple = TRUE) 
```

## Challenges

In your Quarto/RMarkdown document, create new code blocks to do each of the following manipulations/analyses with your graph. I have provided some code hints for you, but I encourage you to NOT look at those, unless you are stuck!

##### Make a preliminary visualization of the graph

```{r}
#| message: false
#| code-fold: true
#| eval: false
plot.igraph(graph)

# or

library(visNetwork)
visIgraph(graph) %>%
  visLayout(randomSeed = 42)
```

##### What is the ***size*** of the graph?

```{r}
#| code-fold: true
#| eval: false
length(V(graph))
```

##### What is the graph ***density***?

> **HINT:** Look at the function `edge_density()` from {igraph}.

```{r}
#| code-fold: true
#| eval: false
edge_density(graph)
```

##### What is the graph ***diameter***?

```{r}
#| code-fold: true
#| eval: false
diameter(graph, weights = NA)
```

##### Which two vertices are ***farthest apart***?

> **HINT:** Look at the function `farthest_vertices()` from {igraph}.

```{r}
#| code-fold: true
#| eval: false
farthest_vertices(graph)
```

##### What is the graph's ***transitivity*** (or ***global clustering coefficient***? What is the ***average local clustering coefficient***?

Can you explain why are these different?

```{r}
#| code-fold: true
#| eval: false
g.transitivity <- transitivity(graph, type = "global")
g.transitivity

l.transitivity <- transitivity(graph, type = "localaverage")
l.transitivity
```

##### How many ***components*** are in the graph?

```{r}
#| code-fold: true
#| eval: false
components(graph)$no # the "no" slot of the object returned from running `components()` contains the number of components
```

##### Convert the graph to an ***adjacency matrix*** and print out the first 10 lines of that matrix

```{r}
#| message: false
#| eval: false
#| code-fold: true
m <- as_adjacency_matrix(graph)
head(m, 10)
```

##### Calculate the ***degree*** of each vertex in the graph

Which three characters have the highest degrees?

> **HINT:** Use the `sort()` function to sort the degree vector in descending order and then select the first three elements in the sorted vector.

```{r}
#| code-fold: true
#| eval: false
d <- degree(graph)
sort(d, decreasing = TRUE)[1:3]
```

##### Calculate and plot the ***degree distribution*** of the graph

```{r}
#| code-fold: true
#| eval: false
hist(d) # plots a histogram

# or, construct your own histogram...

d <- degree_distribution(graph)
x <- seq(0, length(d)-1, by = 1)
barplot(d, names = x, xlab = "degree", ylab = "rel freq")
```

##### Calculate ***betweenness*** and ***closeness*** centrality for each vertex of the graph

Based on these values, which three individuals are most important in the network?

```{r}
#| code-fold: true
#| eval: false
b <- betweenness(graph)
sort(b, decreasing = TRUE)[1:3]

c <- closeness(graph)
sort(c, decreasing = TRUE)[1:3]
```

##### Tweak your visualization!!!

Redraw your graph after scaling each vertex's size to the (square root of its betweenness value, + 10), and see if you can figure out how to make the vertices appear as ORANGE SQUARES, color the edges BLUE, and set the width of the edges to be 10. This will require editing the size, color, and shape attributes of the vertices and the width attribute of your graph's edges.

```{r}
#| code-fold: true
#| eval: false
# add attributes to vertices and edges... this is easy to do with {igraph}
V(graph)$size <- sqrt(b) + 10
V(graph)$color <- "orange"
V(graph)$shape <- "square"
E(graph)$color <- "blue"
E(graph)$width <- 10

# plot with {igraph}
l = layout_with_fr(graph)
plot.igraph(graph, layout = l)

# or, plot with {visNetwork}
visIgraph(graph, randomSeed = 42) %>%
  visIgraphLayout(layout = "layout_with_fr")
```

## Some Final Notes

We could also accomplish some of the steps above by converting our {igraph} object to a {network} object using {intergraph} and then using functions from {statnet} (specifically from the {sna} package, which {statnet} loads) to do some of the calculations indicated above. For example...

```{r}
#| message: false
#| eval: false
library(intergraph)
network <- asNetwork(graph)
library(statnet)

# density
gden(network)

# transitivity
gtrans(network)

# components
components(network)

# degree
degree(network, gmode = "graph")
# {sna} version of this function returns an unamed vector of values

# betweenness
betweenness(network, gmode = "graph", cmode = "undirected")
# {sna} version of this function returns an unamed vector of values
```

Be aware that loading {statnet} (and thus {sna} and {network}), after {igraph} is loaded results in some {igraph} functions being "masked" because the {sna} package include a few functions with exactly the same names! To use {igraph} functions again after {sna} has been loaded, we would need to preface them with `igraph::` to make it clear that we want to use the {igraph} version of the function.

Alternatively, to be sure to use {igraph} versions of the functions, we could unload {sna} by running `detach(package:sna)` before trying to run an {igraph} function again.

> **NOTE:** We can, at any time, preface a function call with the name of the package that it comes from and `::` to run that function without having to load it into our R environment with `library()`!
