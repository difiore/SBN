---
title: "Preliminaries"
format: html
editor_options: 
  chunk_output_type: console
---

# Load in data...

```{r}
# Read in edges and vertices as data frames/tibbles from .csv files using the {tidyverse} package
library(tidyverse)

e <- read_csv("asoiaf-all-edges.csv", col_names = TRUE)
head(e)
tail(e)
glimpse(e)

# Or...

library(shinyDirectoryInput)
dir <- choose.dir()
f <- list.files(path=dir,recursive=FALSE,ignore.case=FALSE, pattern="csv",full.names=TRUE)

head(f)

e <- tibble()
for (i in f){
  x <- read_csv(i, guess_max = 10000) # guess max set close to length of largest
  message(paste0(nrow(x)), " records in file: ", basename(i))
  e <- bind_rows(e, x) # combines tables together, any fields not in a particular table will be filled with NA
}

head(e)
tail(e)
glimpse(e)
```

# Create a graph using visNetwork...

```{r}
library(visNetwork)
```

## visNetwork requires separate data frames for nodes and edges

```{r}
# Start with a data frame that contains edges and weights
edges <- e

# Pick out only edges with high weight...
edges <- filter(e, weight >= 50)
edges <- filter(edges, book == 1)

# Pick out only Cersei
# edges <- filter(e, str_detect(Source, 'Cersei') | str_detect(Target, 'Cersei'))

# Pick out only Stark family
# edges <- filter(e, str_detect(Source, 'Stark|Snow') | str_detect(Target, 'Stark|Snow'))
```

# From this, create a unique list of vertices

```{r}
vertices <- data.frame(
  id = unique(c(edges$Source,edges$Target))
,
  label = unique(c(edges$Source, edges$Target)) # Label to display node names
)
```

# Create a new edges data frame with scaling of widths and changing some column names to meet visNetwork requirements

```{r}
edges <- rename(edges, from = Source, to = Target, type = Type)

edges <- mutate(edges,
  width = weight / max(weight) * 20, # Scale the width
  label = weight, # Label the edges with their weights
  title = paste("Weight:", weight) # Tooltip for the edges
)
```

## use the visNetwork function to create and visualize the network

```{r}
# Create the visNetwork graph
visNetwork(nodes = vertices, edges = edges) %>%
  visEdges(smooth = TRUE) %>%
  visNodes(size = 10) %>%
  visLayout(randomSeed = 42) # Set seed for reproducible layout
```

# How many components in the graph?
# What is the diameter of the largest component?
# Which node has the highest degree? How high?
# If we filter by a higher node weight (e.g., 50), how do your answers change?


# Create the same graph using igraph...

```{r}
# Load the igraph package
library(igraph)

# Use the `graph_from_data_frame()` function to create a graph from a data frame
graph <- graph_from_data_frame(d = edges, vertices = vertices, directed = FALSE)

# show edges
E(graph)
E(graph)$type
E(graph)$weight
E(graph)$width

# show vertices
V(graph)
V(graph)$label

# Use `plot()` function to visualize
plot.igraph(graph,
            vertex.shape="square",
            vertex.size = 5,
            # edge.width = E(graph)$width, # default
            # edge.label = E(graph)$label, # default
            layout =  layout_with_kk(graph))

# or
l <-  layout_with_kk(graph)
plot.igraph(graph,
            vertex.shape="circle",
            vertex.size = 8,
            edge.width = 4,
            edge.label = "",
            layout = l)

# Force-directed layouts try to get a nice-looking graph where edges are similar in length and cross each other as little as possible. They simulate the graph as a physical system.

l <-  layout_with_fr(graph)

plot.igraph(graph,
            vertex.shape="circle",
            vertex.size = 8,
            edge.width = 4,
            edge.label = "",
            layout = l)

as_adjacency_matrix(graph)
as_adjacency_matrix(graph, attr = "weight")
as_edgelist(graph, names = TRUE)
as_adj_list(graph) # vertices adjacent to each vertex
as_adj_edge_list(graph) # edges connected to each vertex

degree(graph)
mean(degree(graph))

dd <- degree_distribution(graph)
x <- seq(0, length(dd)-1, by = 1)
barplot(dd, names = x, xlab = "degree", ylab = "rel freq")
```

# Plot igraph object with visNetwork directly

```{r}
visIgraph(graph)
```

# Convert igraph object to visNetwork and plot, with options

```{r}
graph <- toVisNetworkData(graph, idToLabel = TRUE)

visNetwork(graph$nodes, graph$edges) %>%
  visPhysics(solver = "forceAtlas2Based", forceAtlas2Based = list(gravitationalConstant = -30))

visNetwork(graph$nodes, graph$edges) %>%
  visPhysics(solver = "repulsion")

visNetwork(graph$nodes, graph$edges) %>%
  visOptions(highlightNearest = list(enabled = TRUE, hover = TRUE, degree = 1, hideColor = "rgba(0,0,0,0.05)")) %>%
  visEdges(color = list(inherit = "to"))

visNetwork(graph$nodes, graph$edges) %>% 
  visOptions(manipulation = TRUE) %>%
  visLayout(randomSeed = 123)
```

```{r}
library(igraphdata)
data("foodwebs")
graph <- foodwebs$Narragan
visIgraph(graph)
data("USairports")
visIgraph(USairports)

deg.dist <- degree_distribution(graph, cumulative=T, mode="all")
hist(deg.dist)
plot( x=0:max(degree(graph)), y=1-deg.dist, pch=19, cex=1.2, col="orange", 
      xlab="Degree", ylab="Cumulative Frequency")
```
