---
title: "Preliminary Network Visualization with R"
format:
  html:
    embed-resources: true
    code-overflow: wrap
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    code-summary: "Code hint"
editor_options: 
  chunk_output_type: console
---

# Learning Outcomes

-   Understanding Quarto and RMarkdown documents
-   Understanding functions and arguments
-   Loading a data set: `read_csv()`
-   Peeking at a data set: `head()`, `tail()`, `glimpse()`
-   Wrangling data frames with {tidyverse} commands: `filter()`, `rename()`
-   Creating a data frame from scratch with field names: `data.frame()`
-   Running functions from {visNetwork} and {igraph} and adjusting argument values: `visNetwork()`, `graph_from_data_frame()`, `E()`, `V()`
-   Writing out {igraph} objects to a file, e.g., in ".csv" or ".graphml" format

# Introduction

Today, we are going to do some preliminary exercises for working with network data using R and RStudio. You should use a "Quarto" or "RMarkdown" document for organizing your work and notes to get practice using that approach to doing "reproducible research". Both of these are simple text documents that allow you to mix together narrative text and code to generate formatted, dynamic output. It also allows you to easily manage notes and run code.

## Quarto/RMarkdown and R Basics

-   Use the **File \> New File \> Quarto Document…** or **File \> New File \> R Markdown…** command to create new Quarto or R Markdown documents.

-   Use hashtags (**\#**) to format headers for section titles. The more **\#**’s, the smaller the header.

-   Use markdown syntax to format text

    -   Wrap text in asterisks (e.g., \*italics\*) to create *italicized* text
    -   Wrap text in double asterisks (e.g., \*\*bold\*\*) to create **bold** text
    -   Wrap text in carats (e.g., \^superscript\^) to create ^superscript^ text
    -   Wrap text in tildes (e.g., \~subscript\~\^) to create ~subscript~ text
    -   Wrap text in double tildes (e.g., \~\~strikethrough\~\~) to create ~~strikethrough~~ text
    -   Wrap text in back ticks (e.g., \`inline code\`) to create `inline code`

-   Chunks of R code are included in code blocks that start and end with three back ticks. The opening line of the code block should also include the designator \{r\}, which tells the rendering engine to run the code using R (as opposed to Python, etc.)

```{{r}}
# example code block syntax
print("this is a code block")
```

```{r}
#| echo: false
print("this is a code block")
```

-   Run code by highlighting it in your document and hitting `command-RETURN` or `command-ENTER`. This sends the code to the R console and executes it.

-   A whole block of code can be run by clicking the green right arrow at the top of the code block

-   Comments can be included within R code blocks by prefacing them with \#

-   Use the **Render** (for Quarto documents) or **Knit** (for RMarkdown documents) to create nicely formatted reports based on your notes and code. These commands read through your text file and create an HTML or PDF file that incorporates your syntax, runs the code in your code blocks, and inserts the output of running that code into the report.

# Today's Exercise

## Load in a dataset

We will use a slightly different version of the dataset we were working with last time: social connections among characters in the *Game of Thrones* saga, but only from book one.

```{r}
#| message: false
# read in edges and vertices as data frames/tibbles from .csv files using the {tidyverse} package
library(tidyverse)
```

```{r}
#| eval: false
f <- file.choose()
```

```{r}
#| echo: false
f <- "data/asoiaf-book1-edges.csv"
```

```{r}
#| message: false
e <- read_csv(f, col_names = TRUE)
head(e)
tail(e)
glimpse(e)
```

## Create a graph using the {visNetwork} package...

We will first use the visNetwork package to do a quick visualization of the network. Start by loading in the package...

```{r}
library(visNetwork)
```

{visNetwork} requires separate data frames for nodes and edges, so we create those from our dataset...

```{r}
# we first create a data frame with edges and weights as a simple copy of the dataset we have loaded in
edges <- e
```

Because this dataset is so large, we're going to limit it to only those edges with a high weight...

```{r}
# pick out only edges with high weight
edges <- filter(edges, weight >= 50)
```

From this, we then create a data frame of vertices by selecting all the unique names in either the "Source" or "Target" columns...

```{r}
vertices <- data.frame(
  id = unique(c(edges$Source,edges$Target)),
  label = unique(c(edges$Source, edges$Target))
  # the label argument allows us to display node names
)
```

We then change some column names to meet some requirements for the `visNetwork()` function, e.g., we change "Source" and "Target" to "from" and "to" and we make the "Type" column start with a lowercase letter...

```{r}
edges <- rename(edges, from = Source, to = Target, type = Type)
```

We also add new columns for "width", "label", and "title" to improve our visualization...

```{r}
edges <- mutate(edges,
  width = weight / max(weight) * 20, # scale the width
  label = weight, # label the edges with their weights
  title = paste("Weight:", weight) # tooltip for the edges
)
```

Now, we use the `visNetwork()` function to create and visualize the network... Note that this creates an interactive graph where we can select and move vertices around!

```{r}
# create the visNetwork graph
visNetwork(nodes = vertices, edges = edges) %>%
  visEdges(smooth = TRUE) %>%
  visNodes(size = 20) %>%
  # set a seed for reproducible layout
  visLayout(randomSeed = 42)
```

### Questions

Looking at this graph, answer the following questions...

-   How many **components** are in the graph?
-   What is the **diameter** of the largest component?
-   Which node(s) has the **highest degree**? What is that degree?
-   If we initially filter our dataset by a higher edge weight (e.g., 60), how do these answers change? What about using a lower edge weight (e.g., 40)?

## Create the same graph using the {igraph} package...

```{r}
#| message: false
# Load the igraph package
library(igraph)

# use the `graph_from_data_frame()` function to create a graph from our data frames of edges and vertices
graph <- graph_from_data_frame(
  d = edges,
  vertices = vertices,
  directed = FALSE)
graph
```

We can use the {igraph} functions `E()` and `V()` to get information about the edges and vertices of a graph...

```{r}
# show edge information
E(graph)
E(graph)$type
E(graph)$weight
E(graph)$width

# show vertex information
V(graph)
V(graph)$label
```

Use the `plot.igraph()` function to visualize a graph...

```{r}
l <- layout_in_circle(graph)
plot.igraph(graph,
            vertex.shape="square",
            vertex.size = 5,
            layout = l)
# circle layouts are common, but not always visually informative!
```

{igraph} includes the option to use various "force-directed" layout algorithms for constructing nicer-looking graphs, where the edges are similar in length and cross each other as little as possible

They work by simulating the graph as a physical system

```{r}
l <- layout_with_kk(graph)
plot.igraph(graph,
            vertex.shape="square",
            vertex.size = 5,
            edge.label = "",
            layout = l)
# here, edge widths are determined by the "width" variable we defined above, and edge labels are set to be blank

plot.igraph(graph,
            vertex.shape="circle",
            vertex.size = 8,
            edge.width = 4,
            layout = l)
# here, we set a single edge widths, and edge labels come from the "weight" variable
```

## Some other useful {igraph} functions

Other functions from {igraph} can be run to show alternative representations of the graph properties or to return graph properties...

```{r}
#| message: false
#| warning: false
# show adjacency matrix representation
m <- as_adjacency_matrix(graph)
head(m)

# show adjacency matrix with weights
m <- as_adjacency_matrix(graph, attr = "weight")
head(m)

# show edge list
l <- as_edgelist(graph, names = TRUE)
head(l)

# list vertices adjacent to each vertex
l <- as_adj_list(graph)
head(l)

# list edges connected to each vertex
l <- as_adj_edge_list(graph) 
head(l)

# calculate the degree of each vertex and average degree
degree(graph)
mean(degree(graph)) # average degree

# calculate geodesic distance between all pairs ofvertices using weights
geo_d <- distances(graph)
head(geo_d)

# calculate unweighted geodesic distance between pairs of vertices, ignoring weights
geo_d <- distances(graph, algorithm = "unweighted")
head(geo_d)

# average distance between pairs of vertices
mean_distance( # uses weights
  graph,
  unconnected = TRUE,
  details = FALSE
)
```

## Calculate and plot the degree distribution...

```{r}
d <- degree_distribution(graph)

# the following two lines will plot the degree distribution
x <- seq(0, length(d)-1, by = 1)
barplot(d, names = x, xlab = "degree", ylab = "rel freq")
```

## Write out an {igraph} data to a file...

```{r}
# in .csv format
write_csv(as_long_data_frame(graph), file = "got.csv")

# in .graphml format
write_graph(graph, file = "got.graphml", format = c("graphml"))
```

## Other cool things to explore

### Plot an {igraph} object with {visNetwork} directly

```{r}
visIgraph(graph)
# here, graph is an {igraph} object, and visIgraph() is a function from {visNetwork}
```

### Convert an {igraph} object to a {visNetwork} object

```{r}
graph <- toVisNetworkData(graph, idToLabel = TRUE)
```

### {visNetwork} options

Below are some examples of interesting {visNetwork} options for tweaking graph layouts (e.g., by editing the *physics* of layout positioning) and for interacting with a graph...

```{r}
visNetwork(graph$nodes, graph$edges) %>%
  visPhysics(
    solver = "forceAtlas2Based",
    forceAtlas2Based = list(gravitationalConstant = -30)
    )

visNetwork(graph$nodes, graph$edges) %>%
  visPhysics(solver = "repulsion")

visNetwork(graph$nodes, graph$edges) %>%
  visOptions(
    highlightNearest = list(
      enabled = TRUE,
      hover = TRUE,
      degree = 1,
      hideColor = "rgba(0,0,0,0.05)")
    ) %>%
  visEdges(color = list(inherit = "to"))

visNetwork(graph$nodes, graph$edges) %>% 
  visOptions(manipulation = TRUE) %>%
  visLayout(randomSeed = 42)
```

## Visualizing and working with other datasets from the package {igraphdata}

```{r}
#| message: false
library(igraphdata)
data("foodwebs") # list containing multiple {igraph} objects
graph <- foodwebs$Narragan
visIgraph(graph)

data("USairports") # a single {igraph} object
graph <- USairports
visIgraph(USairports)
```

### Questions

-   Can you calculate the mean degree and plot the degree distribution for each of the new networks graphed above?

## Calculating the "importance" of nodes using centrality measures

Let's go back to the *Game of Thrones* graph in {igraph} format...

```{r}
graph <- graph_from_data_frame(
  d = edges,
  vertices = vertices,
  directed = FALSE)

# we can plot this directly with {visNetwork} and can even call igraph layout routines...
visIgraph(graph) %>%
  visIgraphLayout(layout = "layout_with_kk") %>%
  visLayout(randomSeed = 42)
```

Now, we calculate several standard **node-level metrics of centrality**, which are common ways of characterizing the importance of different nodes in the network.

##### Degree centrality (a.k.a. node degree)

```{r}
degree <- degree(graph)
```

##### Node strength

```{r}
strength <- strength(graph)
```

##### Betweenness

```{r}
bw_weighted <- betweenness( # with edges weighted...
  graph,
  directed = FALSE
)

E(graph)$weight <- 1

bw_unweighted <- betweenness( # with edges set to a uniform weight
  graph,
  directed = FALSE
)
```

##### Eigen centrality

```{r}
eigen <- eigen_centrality(graph)$vector
```

##### Hub and authority scores

```{r}
hub <- hub_score(graph)$vector

authority <- authority_score(graph)$vector
```

##### Closeness centrality

```{r}
closeness <- closeness(graph)
```

##### Reach

"Reach" is calculated as the number of vertices that can be accessed from any particular vertex ("ego") within a specified numbers of steps from each that vertex, scaled by the total number of possible vertices that could be accessed

The {igraph} functions, `ego_size()` or `neighborhood()`, with two arguments ("graph = graph" and "order = k"), return the number of vertices, including "ego", within a given number of steps, k, from "ego", thus `ego_size(graph, 1) - 1` is equivalent to degree!

We divide this number by the total number of vertices other than "ego" in the graph to calculate reach

```{r}
# below, we scale reach by the number of vertices other than ego in the graph, which is a measure of how many possible links ego could have

reach_1 <- (ego_size(graph, 1) - 1) / (vcount(graph) - 1)

reach_2 <- (ego_size(graph, 2) - 1) / (vcount(graph) - 1)

reach_3 <- (ego_size(graph, 3) - 1) / (vcount(graph) - 1)
```

## Customizing visualizations

We can put all these measures together in a data frame and add a "shape" variable for visualization in {visNetwork}

```{r}
centralities <- data.frame(
  id = names(degree),
  label = names(degree),
  degree,
  strength,
  bw_weighted,
  bw_unweighted,
  eigen,
  hub,
  authority,
  closeness,
  reach_1,
  reach_2,
  reach_3,
  shape = "dot") # add a shape attribute so that we can scale shapes

# using {igraph}

l <- layout_with_kk(graph)

plot.igraph(graph,
            layout=l, 
            vertex.size = degree * 3,
            main="Degree")

plot.igraph(graph,
            layout=l, 
            vertex.size= eigen * 15,
            main="Eigen")

plot.igraph(graph,
            layout=l, 
            vertex.size = closeness * 50,
            main="Closeness")

plot.igraph(graph,
            layout=l, 
            vertex.size = bw_weighted * 2,
            main="Betweeness")

# using {visNetwork}
graph <- graph_from_data_frame(
  d = edges,
  vertices = centralities,
  directed = FALSE)

size_var <- "bw_weighted" # try changing which variable to plot by replacing "bw_weighted" with other measures of centrality

centralities <- mutate(centralities, value = centralities[[size_var]])

visNetwork(nodes = centralities, edges = edges) %>%
  visIgraphLayout(layout = "layout_with_kk") %>%
  visLayout(randomSeed = 42)
```

## Transitivity or clustering coefficient

The {igraph} function `transitivity()` can be used to calculate various clustering coefficients

```{r}
transitivity(graph, type = "global")
transitivity(graph, type = "local")
transitivity(graph, type = "localaverage")
```

Transitivity can also be calculated by first converting an {igraph} object to a {network} object using the package {intergraph}, and then using functions bundled in the package {statnet}. To do this conversion, we first install and load the {intergraph} package and then call the conversion function `asNetwork()`...

```{r}
#| message: false
library(intergraph)
network <- asNetwork(graph)
```

We then need to install and load {statnet}, which imports functions from two additional useful packages for network analysis, {sna} and {network}...

```{r}
#| message: false
library(statnet)

# note that we can plot network objects from within the {statnet} package!

# the plotting code below first introduces a new function, `rescale()`, that allows the user to specify a range of values over which to rescale a variable of interest

# then, the `plot.network()` function calls this new function to set vertex sizes...

rescale <- function(variable, low, high) {
  min_d <- min(variable)
  max_d <- max(variable)
  rescaled <- ((high-low) * (variable - min_d)) / (max_d-min_d) + low
  return(rescaled)
}

plot.network(network,
             vertex.cex = rescale(bw_weighted, 1, 6))
```

The {sna} package loaded with {statnet} includes a function called `gtrans()`, which calculates global transitivity...

```{r}
transitivity <- gtrans(network)
transitivity
```
