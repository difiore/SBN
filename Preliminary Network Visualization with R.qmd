---
title: "Preliminary Network Visualization with R"
format:
  html:
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

# Learning Outcomes

-   Understanding Quarto and RMarkdown documents
-   Understanding functions and arguments
-   Loading a data set: `read_csv()`
-   Peeking at a data set: `head()`, `tail()`, `glimpse()`
-   Wrangling data frames with {tidyverse} commands: `filter()`, `rename()`
-   Creating a data frame from scratch with field names: `data.frame()`
-   Running functions from {visNetwork} and {igraph} and adjusting argument values: `visNetwork()`, `graph_from_data_frame()`, `E()`, `V()`
-   Writing out as a .csv or .graphml file

# Introduction

Today, we are going to do some preliminary exercises for working with network data using R and RStudio. You should use a "Quarto" or "RMarkdown" document for organizing your work and notes to get practice using that approach to doing "reproducible research". Both of these are simple text documents that allow you to mix together narrative text and code to generate formatted, dynamic output. It also allows you to easily manage notes and run code.

## Quarto/RMarkdown and R Basics

-   Use the **File \> New File \> Quarto Document…** or **File \> New File \> R Markdown…** command to create new Quarto or R Markdown documents.

-   Use hashtags (**\#**) to format headers for section titles. The more **\#**’s, the smaller the header.

-   Use syntax to format text

    -   Wrap text in asterisks (e.g., \*italics\*) to create *italicized* text
    -   Wrap text in double asterisks (e.g., \*\*bold\*\*) to create **bold** text
    -   Wrap text in carats (e.g., \^superscript\^) to create ^superscript^ text
    -   Wrap text in tildes (e.g., \~subscript\~\^) to create ~subscript~ text
    -   Wrap text in double tildes (e.g., \~\~strikethrough\~\~) to create ~~strikethrough~~ text
    -   Wrap text in back ticks (e.g., \`inline code\`) to create `inline code`

-   Chunks of R code are included in code blocks that start and end with three back ticks. The opening line of the code block should also include the designator \{r\}, which tells the rendering engine to run the code using R (as opposed to Python, etc.)

```{r}
print("this is a code block")
```

-   Run code by highlighting it in your document and hitting `command-RETURN` or `command-ENTER`. This sends the code to the R console and executes it.

-   A whole block of code can be run by clicking the green right arrow at the top of the code block

-   Comments can be included within R code blocks by prefacing them with \#

-   Use the **Render** (for Quarto documents) or **Knit** (for RMarkdown documents) to create nicely formatted reports based on your notes and code. These commands read through your text file and create an HTML or PDF file that incorporates your syntax, runs the code in your code blocks, and inserts the output of running that code into the report.

# Today's Exercise

## Load in a dataset

We will use a slightly different version of the dataset we were working with last time: social connections among characters in the *Game of Thrones* saga, but only from book one.

```{r}
#| message: false
# read in edges and vertices as data frames/tibbles from .csv
# files using the {tidyverse} package
library(tidyverse)
```

```{r}
#| eval: false
f <- file.choose()
```

```{r}
#| echo: false
f <- "data/asoiaf-book1-edges.csv"
```

```{r}
#| message: false
e <- read_csv(f, col_names = TRUE)
head(e)
tail(e)
glimpse(e)
```

## Create a graph using the {visNetwork} package...

We will first use the visNetwork package to do a quick visualization of the network. Start by loading in the package...

```{r}
library(visNetwork)
```

{visNetwork} requires separate data frames for nodes and edges, so we create those from our dataset...

```{r}
# we first create a data frame with edges and weights as a simple
# copy of the dataset we have loaded in
edges <- e
```

Because this dataset is so large, we're going to limit it to only those edges with a high weight...

```{r}
# pick out only edges with high weight
edges <- filter(e, weight >= 50)
```

From this, we then create a data frame of vertices by selecting all the unique names in either the "Source" or "Target" columns...

```{r}
vertices <- data.frame(
  id = unique(c(edges$Source,edges$Target)),
  label = unique(c(edges$Source, edges$Target))
  # the label argument allows us to display node names
)
```

We then change some column names to meet some requirements for the `visNetwork()` function, e.g., we change "Source" and "Target" to "from" and "to" and we make the "Type" column start with a lowercase letter...

```{r}
edges <- rename(edges, from = Source, to = Target, type = Type)
```

We also add new columns for "width", "label", and "title" to improve our visualization...

```{r}
edges <- mutate(edges,
  width = weight / max(weight) * 20, # scale the width
  label = weight, # label the edges with their weights
  title = paste("Weight:", weight) # tooltip for the edges
)
```

Now, we use the `visNetwork()` function to create and visualize the network... Note that this creates an interactive graph where we can select and move vertices around!

```{r}
# create the visNetwork graph
visNetwork(nodes = vertices, edges = edges) %>%
  visEdges(smooth = TRUE) %>%
  visNodes(size = 10) %>%
  # set a seed for reproducible layout
  visLayout(randomSeed = 42)
```

### Questions

Looking at this graph, answer the following questions...

-   How many **components** are in the graph?
-   What is the **diameter** of the largest component?
-   Which node(s) has the **highest degree**? What is that degree?
-   If we initially filter our dataset by a higher edge weight (e.g., 60), how do these answers change? What about using a lower edge weight (e.g., 40)?

## Create the same graph using the {igraph} package...

```{r}
#| message: false
# Load the igraph package
library(igraph)

# use the `graph_from_data_frame()` function to create a graph from
# our data frames of edges and vertices
graph <- graph_from_data_frame(
  d = edges,
  vertices = vertices,
  directed = FALSE)
graph
```

We can use the {igraph} functions `E()` and `V()` to get information about the edges and vertices of a graph...

```{r}
# show edge information
E(graph)
E(graph)$type
E(graph)$weight
E(graph)$width

# show vertex information
V(graph)
V(graph)$label
```

Use the `plot.igraph()` function to visualize a graph...

```{r}
l <- layout_in_circle(graph)
plot.igraph(graph,
            vertex.shape="square",
            vertex.size = 5,
            layout = l)
# circle layouts are common, but not always visually informative!
```

{igraph} includes the option to use various "force-directed" layout algorithms for constructing nicer-looking graphs, where the edges are similar in length and cross each other as little as possible

They work by simulating the graph as a physical system

```{r}
l <- layout_with_kk(graph)
plot.igraph(graph,
            vertex.shape="square",
            vertex.size = 5,
            edge.label = "",
            layout = l)
# here, edge widths are determined by the "width" variable we defined above,
# and edge labels are set to be blank

plot.igraph(graph,
            vertex.shape="circle",
            vertex.size = 8,
            edge.width = 4,
            layout = l)
# here, we set a single edge widths, and edge labels come from the "weight" variable
```

## Some other useful {igraph} functions

Other functions from {igraph} can be run to show alternative representations of the graph properties or to return graph properties...

```{r}
#| message: false
# show adjacency matrix representation
am <- as_adjacency_matrix(graph)
head(am)

# show adjacency matrix with weights
am <- as_adjacency_matrix(graph, attr = "weight")
head(am)

# show edge list
el <- as_edgelist(graph, names = TRUE)
head(el)

# list vertices adjacent to each vertex
al <- as_adj_list(graph)
head(al)

# list edges connected to each vertex
ael <- as_adj_edge_list(graph) 
head(ael)

# calculate the degree of each vertex
degree(graph)
mean(degree(graph)) # average degree

# calculate geodesic distance between all pairs ofvertices using weights
geo_d <- distances(graph)
head(geo_d)

# calculate unweighted geodesic distance between pairs of
# vertices, ignoring weights
geo_d <- distances(graph, algorithm = "unweighted")
head(geo_d)

# average distance between pairs of vertices
mean_distance( # uses weights
  graph,
  unconnected = TRUE,
  details = FALSE
)
```

## Calculate and plot the degree distribution...

```{r}
dd <- degree_distribution(graph)

# the following two lines plot the degree distribution
x <- seq(0, length(dd)-1, by = 1)
barplot(dd, names = x, xlab = "degree", ylab = "rel freq")
```

## Write out an {igraph} data to a file...

```{r}
# in .csv format
write_csv(as_long_data_frame(graph), file = "~/Desktop/got.csv")

# in .graphml format
write_graph(graph, file = "~/Desktop/got.graphml", format = c("graphml"))
```

# Other cool things to explore

## Plot an {igraph} object with {visNetwork} directly

```{r}
visIgraph(graph)
# here, graph is an {igraph} object, and
# visIgraph() is a function from {visNetwork}
```

## Convert an {igraph} object to a {visNetwork} object

```{r}
graph <- toVisNetworkData(graph, idToLabel = TRUE)
```

## {visNetwork} options

Below are some examples of interesting {visNetwork} options for tweaking graph layouts (e.g., by editing the *physics* of layout positioning) and for interacting with a graph...

```{r}
visNetwork(graph$nodes, graph$edges) %>%
  visPhysics(
    solver = "forceAtlas2Based",
    forceAtlas2Based = list(gravitationalConstant = -30)
    )

visNetwork(graph$nodes, graph$edges) %>%
  visPhysics(solver = "repulsion")

visNetwork(graph$nodes, graph$edges) %>%
  visOptions(
    highlightNearest = list(
      enabled = TRUE,
      hover = TRUE,
      degree = 1,
      hideColor = "rgba(0,0,0,0.05)")
    ) %>%
  visEdges(color = list(inherit = "to"))

visNetwork(graph$nodes, graph$edges) %>% 
  visOptions(manipulation = TRUE) %>%
  visLayout(randomSeed = 123)
```

# Visualizing and working with other datasets from the package {igraphdata}

```{r}
#| message: false
library(igraphdata)
data("foodwebs") # list containing multiple {igraph} objects
graph <- foodwebs$Narragan
visIgraph(graph)

data("USairports") # a single {igraph} object
graph <- USairports
visIgraph(USairports)
```

### Questions

-   Calculate the mean degree and plot the degree distribution for each of the new networks graphed above
